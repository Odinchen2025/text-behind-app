<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Text Mask Tool V9 (Smart Touch)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;900&display=swap" rel="stylesheet">
    <style>
        body { background-color: #000; color: white; touch-action: none; overflow: hidden; font-family: 'Noto Sans TC', sans-serif; }
        
        /* ç•«å¸ƒå€è¨­å®šæ¸¸æ¨™ */
        #canvas-wrapper { 
            position: relative; width: 100vw; height: 60vh; 
            background: #111; display: flex; justify-content: center; align-items: center; 
            overflow: hidden;
        }

        /* è¼‰å…¥å‹•ç•« */
        #loading-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999; display: none; flex-direction: column; justify-content: center; align-items: center; }
        .spinner { width: 40px; height: 40px; border: 4px solid #444; border-top: 4px solid #3b82f6; border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* UI */
        .controls { height: 40vh; background: #222; display: flex; flex-direction: column; z-index: 100; box-shadow: 0 -4px 10px rgba(0,0,0,0.5); }
        .tab-btn { flex: 1; padding: 12px; text-align: center; font-size: 14px; color: #666; border-bottom: 2px solid #333; transition: all 0.2s; }
        .tab-btn.active { color: #60a5fa; border-bottom: 2px solid #60a5fa; font-weight: bold; background: #2a2a2a; }
        
        input[type=range] { -webkit-appearance: none; background: transparent; height: 30px; width: 100%; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 22px; width: 22px; border-radius: 50%; background: #3b82f6; margin-top: -8px; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 6px; background: #444; border-radius: 3px; }
    </style>
</head>
<body class="flex flex-col h-screen">

    <div id="loading-layer">
        <div class="spinner"></div>
        <div id="loading-text" class="text-gray-300 font-bold">ç…§ç‰‡è™•ç†ä¸­...</div>
    </div>

    <div class="flex justify-between items-center px-4 py-3 bg-gray-900 border-b border-gray-800 z-50">
        <span class="font-bold text-blue-400 text-xs tracking-tighter">SMART MASK V9</span>
        <div class="flex gap-2">
            <label class="bg-blue-600 px-3 py-1.5 rounded text-xs font-bold cursor-pointer text-white active:scale-95 transition">
                ğŸ“‚ é–‹å•Ÿç…§ç‰‡
                <input type="file" id="file-input" accept="image/*" class="hidden">
            </label>
            <button onclick="saveImage()" class="bg-gray-700 px-3 py-1.5 rounded text-xs font-bold text-white active:scale-95 transition">ğŸ’¾ å­˜åœ–</button>
        </div>
    </div>

    <div id="canvas-wrapper">
        <canvas id="c"></canvas>
    </div>

    <div class="controls">
        <div class="flex">
            <div id="tab-text" onclick="switchMode('text')" class="tab-btn active">1. ç·¨è¼¯æ–‡å­—</div>
            <div id="tab-mask" onclick="switchMode('mask')" class="tab-btn">2. å¡—æŠ¹é®ç½©</div>
        </div>
        
        <div id="panel-text" class="flex-1 p-4 space-y-4">
            <div class="flex gap-2">
                <button onclick="addText()" class="flex-1 bg-gray-700 py-3 rounded text-sm font-bold text-white active:bg-gray-600">+ æ–°å¢æ–‡å­—</button>
                <button onclick="resetZoom()" class="px-3 bg-gray-800 border border-gray-600 rounded text-xs text-gray-300">é‡ç½®è¦–è§’</button>
            </div>
            <input type="text" id="val-text" class="w-full bg-gray-800 border border-gray-600 rounded p-3 text-sm text-white text-center" placeholder="é»é¸æ–‡å­—é€²è¡Œç·¨è¼¯">
            <div class="flex items-center gap-2">
                <span class="text-xs text-gray-500">é¡è‰²</span>
                <input type="color" id="val-color" class="w-10 h-10 rounded bg-transparent border-none">
                <span class="text-xs text-gray-500 ml-2">é€æ˜åº¦</span>
                <input type="range" id="val-opacity" min="0" max="1" step="0.1" value="1" class="flex-1">
            </div>
        </div>

        <div id="panel-mask" class="hidden flex-1 p-4 flex flex-col items-center">
            <div class="w-full bg-blue-900/20 border border-blue-900/50 p-2 rounded text-[11px] text-blue-200 text-center mb-3">
                ğŸ–ï¸ <b>æ™ºæ…§æ“ä½œï¼š</b>å–®æŒ‡å¡—æŠ¹ï¼Œé›™æŒ‡æ”¾å¤§/ç§»å‹•<br>
                (ä¸ç”¨åˆ‡æ›æŒ‰éˆ•ï¼Œç›´æ¥æ“ä½œå³å¯)
            </div>
            <div class="flex gap-3 w-full mb-4 px-2">
                <button onclick="undoMask()" class="flex-1 bg-gray-700 py-3 rounded text-sm font-bold text-white active:scale-95">â†©ï¸ æ’¤éŠ·</button>
                <button onclick="resetMask()" class="flex-1 bg-red-900/40 text-red-200 py-3 rounded text-sm font-bold active:scale-95">ğŸ—‘ï¸ æ¸…é™¤</button>
            </div>
            <div class="w-full px-2">
                <div class="flex justify-between text-xs text-gray-500 mb-2"><span>ç­†åˆ·å¤§å°</span><span id="brush-size-val">30</span></div>
                <input type="range" id="val-brush" min="5" max="80" value="30">
            </div>
        </div>
    </div>

    <script>
        let canvas, bgImage, topMaskLayer, maskPaths = [], isMaskMode = false;
        const loadingLayer = document.getElementById('loading-layer');

        // åˆå§‹åŒ–
        window.onload = () => {
            const wrapper = document.getElementById('canvas-wrapper');
            canvas = new fabric.Canvas('c', { 
                backgroundColor: '#111', 
                width: wrapper.clientWidth, 
                height: wrapper.clientHeight, 
                selection: false,
                allowTouchScrolling: false // ç¦æ­¢ç€è¦½å™¨æ»¾å‹•
            });

            // ----------------------------------------------------
            // ğŸ’¡ é—œéµä¿®æ­£ 1: æ™ºæ…§æ‰‹å‹¢åµæ¸¬ (ä¸€æŒ‡ç•«ç•«ï¼Œå…©æŒ‡ç¸®æ”¾)
            // ----------------------------------------------------
            canvas.upperCanvasEl.addEventListener('touchstart', function(e) {
                if (isMaskMode) {
                    // å¦‚æœåµæ¸¬åˆ° 2 éš»æ‰‹æŒ‡ï¼Œæš«æ™‚é—œé–‰ç¹ªåœ–æ¨¡å¼ï¼Œè®“ Zoom é‚è¼¯æ¥æ‰‹
                    if (e.touches.length === 2) {
                        canvas.isDrawingMode = false;
                    } else {
                        canvas.isDrawingMode = true;
                    }
                }
            }, { passive: false });

            // ç›£è½æ‰‹æŒ‡é›¢é–‹ï¼šå¦‚æœå›åˆ° 0 æˆ– 1 æŒ‡ï¼Œæ¢å¾©åŸæœ¬æ¨¡å¼è¨­å®š
            canvas.upperCanvasEl.addEventListener('touchend', function(e) {
                if (isMaskMode && e.touches.length === 0) {
                    canvas.isDrawingMode = true;
                }
            });

            // ----------------------------------------------------
            // Zoom & Pan é‚è¼¯ (é›™æŒ‡ç¸®æ”¾èˆ‡å¹³ç§»)
            // ----------------------------------------------------
            let lastV;
            canvas.on('touch:gesture', function(e) {
                if (e.e.touches && e.e.touches.length === 2) {
                    // è¨ˆç®—ç¸®æ”¾
                    let p1 = { x: e.e.touches[0].pageX, y: e.e.touches[0].pageY };
                    let p2 = { x: e.e.touches[1].pageX, y: e.e.touches[1].pageY };
                    let v = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                    
                    if (lastV) {
                        let zoom = canvas.getZoom();
                        zoom *= v / lastV;
                        zoom = Math.min(Math.max(zoom, 0.5), 10); // é™åˆ¶ç¸®æ”¾ 0.5x ~ 10x
                        
                        // ä»¥é›™æŒ‡ä¸­å¿ƒé»é€²è¡Œç¸®æ”¾
                        let center = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 - 50 };
                        canvas.zoomToPoint(center, zoom);
                    }
                    lastV = v;
                }
            });

            canvas.on('touch:drag', function(e) {
                // é›™æŒ‡æ‹–æ›³å¹³ç§»
                if (isMaskMode && !canvas.isDrawingMode) {
                    let delta = new fabric.Point(e.self.x, e.self.y);
                    canvas.relativePan(delta);
                } else if (!isMaskMode && e.e.touches && e.e.touches.length === 2) {
                    let delta = new fabric.Point(e.self.x, e.self.y);
                    canvas.relativePan(delta);
                }
            });

            canvas.on('mouse:up', () => { lastV = undefined; });
        };

        function resetZoom() {
            canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
        }

        // åœ–ç‰‡è®€å–
        document.getElementById('file-input').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            loadingLayer.style.display = 'flex';

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    // é™å£“è™•ç†
                    const offscreenCanvas = document.createElement('canvas');
                    const maxDim = 1500; 
                    let width = img.width, height = img.height;
                    if (width > height) { if (width > maxDim) { height *= maxDim / width; width = maxDim; } }
                    else { if (height > maxDim) { width *= maxDim / height; height = maxDim; } }
                    offscreenCanvas.width = width; offscreenCanvas.height = height;
                    offscreenCanvas.getContext('2d').drawImage(img, 0, 0, width, height);

                    fabric.Image.fromURL(offscreenCanvas.toDataURL('image/jpeg', 0.8), (fImg) => {
                        canvas.clear(); resetZoom(); maskPaths = [];
                        
                        // ----------------------------------------------------
                        // ğŸ’¡ é—œéµä¿®æ­£ 2: åº§æ¨™æ­¸é›¶ (è§£æ±ºå¡—æŠ¹ä½ç§»)
                        // ----------------------------------------------------
                        // å°‡åœ–ç‰‡å¼·åˆ¶è¨­ç‚ºå·¦ä¸Šè§’ (0,0) å°é½Šï¼Œè€Œéä¸­å¿ƒå°é½Š
                        // é€™æ¨£ç­†åˆ·çš„çµ•å°åº§æ¨™èˆ‡åœ–ç‰‡åº§æ¨™å°±æœƒæ°¸é ä¸€è‡´
                        const scale = Math.min(canvas.width / fImg.width, canvas.height / fImg.height);
                        
                        fImg.set({ 
                            originX: 'left', 
                            originY: 'top', 
                            left: 0, 
                            top: 0, 
                            scaleX: scale, 
                            scaleY: scale, 
                            selectable: false, 
                            evented: false 
                        });
                        
                        bgImage = fImg; 
                        canvas.add(bgImage);

                        // å»ºç«‹é®ç½©å±¤
                        bgImage.clone((cloned) => {
                            topMaskLayer = cloned;
                            topMaskLayer.set({ 
                                selectable: false, 
                                evented: false, 
                                absolutePositioned: true, 
                                clipPath: new fabric.Group([], { absolutePositioned: true }) 
                            });
                            canvas.add(topMaskLayer);
                            addText(); // æ–°å¢æ–‡å­—
                            loadingLayer.style.display = 'none';
                        });
                    });
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        };

        function addText() {
            // æ–‡å­—é è¨­æ”¾åœ¨ç•«é¢ä¸­å¤®
            const t = new fabric.IText('æ–‡å­—ç‰¹æ•ˆ', { 
                left: (bgImage.width * bgImage.scaleX) / 2, 
                top: (bgImage.height * bgImage.scaleY) / 2, 
                originX: 'center', 
                originY: 'center', 
                fontFamily: 'Noto Sans TC', 
                fill: '#ffffff', fontSize: 60, fontWeight: '900',
                shadow: new fabric.Shadow({ color: 'rgba(0,0,0,0.5)', blur: 10, offsetX: 5, offsetY: 5 })
            });
            canvas.add(t);
            canvas.setActiveObject(t);
            if(topMaskLayer) canvas.bringToFront(topMaskLayer);
        }

        // æ¨¡å¼åˆ‡æ›
        function switchMode(mode) {
            isMaskMode = (mode === 'mask');
            document.getElementById('tab-text').className = isMaskMode ? 'tab-btn' : 'tab-btn active';
            document.getElementById('tab-mask').className = isMaskMode ? 'tab-btn active' : 'tab-btn';
            document.getElementById('panel-text').className = isMaskMode ? 'hidden' : 'flex-1 p-4 space-y-4';
            document.getElementById('panel-mask').className = isMaskMode ? 'flex-1 p-4 flex flex-col items-center' : 'hidden';
            
            if(isMaskMode) {
                canvas.discardActiveObject().renderAll();
                canvas.isDrawingMode = true; // é è¨­é–‹å•Ÿç¹ªåœ–
                
                // è¨­å®šåŠé€æ˜ç´…è‰²ç­†åˆ·
                const brush = new fabric.PencilBrush(canvas);
                brush.color = "rgba(255, 50, 50, 0.5)";
                brush.width = parseInt(document.getElementById('val-brush').value);
                canvas.freeDrawingBrush = brush;
            } else {
                canvas.isDrawingMode = false;
            }
        }

        // å¡—æŠ¹è·¯å¾‘è™•ç†
        setTimeout(() => {
            canvas.on('path:created', (e) => {
                if (!isMaskMode) return;
                const path = e.path;
                canvas.remove(path); // ç§»é™¤ç´…ç·š

                path.clone((cloned) => {
                    // å°‡ç­†åˆ·è½‰ç‚ºä¸é€æ˜é®ç½©ï¼Œä¸¦å›ºå®šåº§æ¨™
                    cloned.set({ 
                        stroke: 'black', 
                        fill: null, 
                        strokeWidth: path.strokeWidth, 
                        strokeLineCap: 'round', 
                        strokeLineJoin: 'round', 
                        left: path.left, 
                        top: path.top,
                        globalCompositeOperation: 'source-over'
                    });
                    maskPaths.push(cloned);
                    applyMask();
                });
            });
        }, 500);

        function applyMask() {
            if(!topMaskLayer) return;
            // é—œéµï¼šä½¿ç”¨ absolutePositioned ç¢ºä¿é®ç½©èˆ‡å·¦ä¸Šè§’å°é½Š
            const group = new fabric.Group(maskPaths, { absolutePositioned: true, inverted: false });
            topMaskLayer.clipPath = group;
            topMaskLayer.dirty = true;
            canvas.requestRenderAll();
        }

        function undoMask() { if (maskPaths.length > 0) { maskPaths.pop(); applyMask(); } }
        function resetMask() { maskPaths = []; applyMask(); }
        
        // UI äº‹ä»¶
        document.getElementById('val-text').oninput = (e) => { const o = canvas.getActiveObject(); if(o && o.type==='i-text'){ o.set('text', e.target.value); canvas.renderAll(); }};
        document.getElementById('val-color').oninput = (e) => { const o = canvas.getActiveObject(); if(o && o.type==='i-text'){ o.set('fill', e.target.value); canvas.renderAll(); }};
        document.getElementById('val-opacity').oninput = (e) => { const o = canvas.getActiveObject(); if(o && o.type==='i-text'){ o.set('opacity', parseFloat(e.target.value)); canvas.renderAll(); }};
        document.getElementById('val-brush').oninput = (e) => { 
            document.getElementById('brush-size-val').innerText = e.target.value; 
            if(canvas.freeDrawingBrush) canvas.freeDrawingBrush.width = parseInt(e.target.value); 
        };

        function saveImage() {
            // å­˜åœ–å‰æš«æ™‚é‚„åŸè¦–è§’ï¼Œç¢ºä¿æ•´å¼µåœ–éƒ½è¢«è¼¸å‡º
            const vpt = canvas.viewportTransform;
            canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
            canvas.discardActiveObject().renderAll();
            
            const link = document.createElement('a');
            link.href = canvas.toDataURL({ format: 'png', multiplier: 2 });
            link.download = 'Text_Behind_V9.png';
            link.click();
            
            // å­˜å®Œåœ–å¾Œæ¢å¾©ä½¿ç”¨è€…çš„è¦–è§’
            canvas.setViewportTransform(vpt);
            canvas.requestRenderAll();
        }
    </script>
</body>
</html>
