<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Text Mask Tool V4 (Stable)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;900&display=swap" rel="stylesheet">
    <style>
        body { background-color: #000; color: white; touch-action: none; overflow: hidden; font-family: 'Noto Sans TC', sans-serif; }
        
        /* ç•«å¸ƒå€åŸŸ */
        #canvas-wrapper { 
            position: relative; width: 100vw; height: 55vh; 
            background: #1a1a1a; display: flex; justify-content: center; align-items: center; overflow: hidden;
        }

        /* è¼‰å…¥é®ç½© */
        #loading-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 4px solid #3b82f6;
            width: 40px; height: 40px; animation: spin 1s linear infinite; mb-2;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* æ§åˆ¶å€ */
        .controls { height: 45vh; background: #222; display: flex; flex-direction: column; }
        
        /* é ç±¤æ¨£å¼ */
        .tab-btn { flex: 1; padding: 12px; text-align: center; font-size: 14px; color: #888; border-bottom: 2px solid #333; transition: 0.2s; }
        .tab-btn.active { color: #60a5fa; border-bottom: 2px solid #60a5fa; font-weight: bold; background: #2a2a2a; }

        input[type=range] { -webkit-appearance: none; background: transparent; height: 30px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%; background: #3b82f6; margin-top: -8px; box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #4b5563; border-radius: 2px; }
    </style>
</head>
<body class="flex flex-col h-screen">

    <div id="loading-layer" class="hidden">
        <div class="spinner"></div>
        <div class="mt-4 text-blue-400 font-bold">è™•ç†ä¸­...</div>
    </div>

    <div class="flex justify-between items-center px-4 py-3 bg-gray-900 border-b border-gray-800">
        <span class="font-bold text-gray-300 text-sm">TEXT MASK V4</span>
        <div class="flex gap-2">
            <label class="bg-gray-700 hover:bg-gray-600 px-3 py-1.5 rounded text-xs font-bold transition cursor-pointer flex items-center">
                ğŸ“‚ é–‹å•Ÿ
                <input type="file" id="file-input" accept="image/*" class="hidden">
            </label>
            <button onclick="saveImage()" class="bg-blue-600 hover:bg-blue-500 px-3 py-1.5 rounded text-xs font-bold transition">ğŸ’¾ å­˜åœ–</button>
        </div>
    </div>

    <div id="canvas-wrapper">
        <canvas id="c"></canvas>
    </div>

    <div class="controls">
        <div class="flex">
            <div id="tab-text" onclick="switchMode('text')" class="tab-btn active">A. æ–‡å­—ç·¨è¼¯</div>
            <div id="tab-mask" onclick="switchMode('mask')" class="tab-btn">B. é®ç½© (äººç‰©)</div>
        </div>

        <div id="panel-text" class="flex-1 p-4 overflow-y-auto space-y-4">
            <button onclick="addNewText()" class="w-full bg-gray-700 py-3 rounded text-sm font-bold border border-gray-600 shadow-sm active:bg-gray-600">+ æ–°å¢æ–‡å­—</button>
            
            <div class="space-y-3">
                <div class="flex items-center gap-2">
                    <span class="text-xs text-gray-400 w-8">å…§å®¹</span>
                    <input type="text" id="val-text" class="flex-1 bg-gray-800 border border-gray-600 rounded p-2 text-sm text-white" placeholder="é»é¸æ–‡å­—ä¿®æ”¹">
                </div>
                <div class="flex items-center gap-2">
                    <span class="text-xs text-gray-400 w-8">æ¨£å¼</span>
                    <input type="color" id="val-color" class="w-8 h-8 rounded border-none bg-transparent cursor-pointer">
                    <input type="range" id="val-opacity" min="0" max="1" step="0.1" value="1" class="flex-1 ml-2">
                </div>
            </div>
            <p class="text-xs text-gray-500 text-center mt-2">ğŸ’¡ æç¤ºï¼šå–®æŒ‡æ‹–æ›³æ–‡å­—ï¼Œé›™æŒ‡å¯æ—‹è½‰/ç¸®æ”¾</p>
        </div>

        <div id="panel-mask" class="hidden flex-1 p-4 flex flex-col items-center">
            <div class="bg-blue-900/30 text-blue-300 border border-blue-800 p-2 rounded text-xs w-full text-center mb-4">
                ğŸ–Œï¸ ç”¨æ‰‹æŒ‡å¡—æŠ¹ç…§ç‰‡ä¸­çš„<b>äººç‰©</b><br>
                <span class="text-gray-400">(å¡—æŠ¹è™•æœƒæµ®ç¾åˆ°æ–‡å­—ä¸Šæ–¹)</span>
            </div>
            
            <div class="flex gap-3 w-full mb-4">
                <button onclick="undoLastMask()" class="flex-1 bg-gray-700 py-3 rounded text-sm font-bold active:scale-95">â†©ï¸ æ’¤éŠ·</button>
                <button onclick="resetMask()" class="flex-1 bg-red-900/40 text-red-300 border border-red-900/50 py-3 rounded text-sm font-bold active:scale-95">ğŸ—‘ï¸ å…¨éƒ¨æ¸…é™¤</button>
            </div>

            <div class="w-full">
                <div class="flex justify-between text-xs text-gray-400 mb-1">
                    <span>ç­†åˆ·å¤§å°</span>
                    <span id="brush-size-text">30</span>
                </div>
                <input type="range" id="val-brush" min="5" max="80" value="30" class="w-full">
            </div>
        </div>
    </div>

    <script>
        // 1. åˆå§‹åŒ– Fabric Canvas
        const canvas = new fabric.Canvas('c', {
            backgroundColor: '#1a1a1a',
            preserveObjectStacking: true, // é‡è¦ï¼šä¿æŒåœ–å±¤é †åº
            selection: false // æ‰‹æ©Ÿç¦ç”¨æ¡†é¸
        });

        // å…¨åŸŸè®Šæ•¸
        let bgImage = null;       // åº•åœ–
        let topMaskLayer = null;  // é®ç½©å±¤ (è¤‡è£½çš„åº•åœ–)
        let maskPaths = [];       // ç­†è§¸è·¯å¾‘
        let isProcessing = false;

        // UI å…ƒç´ 
        const loadingEl = document.getElementById('loading-layer');
        const fileInput = document.getElementById('file-input');

        // è¢å¹•å°ºå¯¸èª¿æ•´
        function resizeCanvas() {
            const wrapper = document.getElementById('canvas-wrapper');
            if (wrapper.clientWidth && wrapper.clientHeight) {
                canvas.setWidth(wrapper.clientWidth);
                canvas.setHeight(wrapper.clientHeight);
                canvas.renderAll();
            }
        }
        window.addEventListener('resize', resizeCanvas);
        setTimeout(resizeCanvas, 100); // ç¢ºä¿ CSS è¼‰å…¥å¾ŒåŸ·è¡Œ

        // 2. åœ–ç‰‡ä¸Šå‚³é‚è¼¯ (V4 ç©©å®šç‰ˆ)
        fileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            // é¡¯ç¤ºè¼‰å…¥ä¸­
            loadingEl.classList.remove('hidden');
            
            const reader = new FileReader();
            reader.onload = function(f) {
                const dataUrl = f.target.result;
                
                // ä½¿ç”¨ fromURL è®€å– (è¼ƒç©©å®š)
                fabric.Image.fromURL(dataUrl, function(img) {
                    if (!img) {
                        alert('åœ–ç‰‡è®€å–å¤±æ•—ï¼Œè«‹æ›ä¸€å¼µè©¦è©¦ã€‚');
                        loadingEl.classList.add('hidden');
                        return;
                    }

                    try {
                        // é‡ç½®ç‹€æ…‹
                        canvas.clear();
                        maskPaths = [];
                        canvas.setBackgroundColor('#1a1a1a', canvas.renderAll.bind(canvas));

                        // é™åˆ¶æœ€å¤§å°ºå¯¸ (é˜²æ­¢æ‰‹æ©Ÿå´©æ½°)
                        const maxDim = 1280; 
                        if (img.width > maxDim || img.height > maxDim) {
                            img.scaleToWidth(maxDim);
                        }

                        // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹ (Contain)
                        const scale = Math.min(
                            canvas.width / (img.width * img.scaleX),
                            canvas.height / (img.height * img.scaleY)
                        ) || 0.5; // é˜²æ­¢ scale ç‚º Infinity

                        img.set({
                            originX: 'center', originY: 'center',
                            left: canvas.width / 2, top: canvas.height / 2,
                            scaleX: img.scaleX * scale,
                            scaleY: img.scaleY * scale,
                            selectable: false, evented: false
                        });

                        bgImage = img;
                        canvas.add(bgImage);
                        
                        // å»ºç«‹é®ç½©å±¤ (éåŒæ­¥è™•ç†ä»¥é¿å…å¡é “)
                        setTimeout(() => {
                            initTopMaskLayer(img); // å‚³å…¥åŸå§‹ img ç‰©ä»¶
                            loadingEl.classList.add('hidden'); // é—œé–‰è¼‰å…¥
                            addNewText(); // è‡ªå‹•åŠ å€‹æ–‡å­—æ–¹ä¾¿æ¸¬è©¦
                        }, 50);

                    } catch (err) {
                        alert('è™•ç†éŒ¯èª¤: ' + err.message);
                        loadingEl.classList.add('hidden');
                    }
                }, { crossOrigin: 'anonymous' }); // å˜—è©¦è§£æ±ºæŸäº›è·¨åŸŸå•é¡Œ
            };
            reader.onerror = () => {
                alert('æª”æ¡ˆè®€å–éŒ¯èª¤');
                loadingEl.classList.add('hidden');
            };
            reader.readAsDataURL(file);
        });

        // 3. å»ºç«‹é ‚å±¤é®ç½© (è¤‡è£½åº•åœ–)
        function initTopMaskLayer(sourceImg) {
            sourceImg.clone(function(cloned) {
                topMaskLayer = cloned;
                topMaskLayer.set({
                    selectable: false, 
                    evented: false,
                    absolutePositioned: true, // é—œéµï¼šçµ•å°å®šä½ç¢ºä¿é‡ç–Š
                    // åˆå§‹è¨­å®šä¸€å€‹ç©ºçš„ clipPath
                    clipPath: new fabric.Group([], { absolutePositioned: true }) 
                });
                canvas.add(topMaskLayer);
                canvas.renderAll();
            });
        }

        // 4. æ–‡å­—ç·¨è¼¯é‚è¼¯
        function addNewText() {
            if (!bgImage) return;
            const text = new fabric.IText('ç·¨è¼¯æ–‡å­—', {
                left: canvas.width / 2, top: canvas.height / 2,
                originX: 'center', originY: 'center',
                fontFamily: 'Noto Sans TC', fill: '#ffffff',
                fontSize: 60, fontWeight: '900',
                shadow: new fabric.Shadow({ color: 'rgba(0,0,0,0.5)', blur: 10, offsetX: 5, offsetY: 5 })
            });
            canvas.add(text);
            canvas.setActiveObject(text);
            
            // ç¢ºä¿æ–‡å­—åœ¨é®ç½©å±¤ä¸‹é¢ï¼Œåº•åœ–ä¸Šé¢ (Canvas è‡ªå‹•è™•ç†é †åºï¼Œåªè¦ TopLayer æ˜¯æœ€å¾ŒåŠ çš„)
            // å¦‚æœéœ€è¦ï¼Œå¼·åˆ¶ TopLayer ç½®é ‚
            if(topMaskLayer) canvas.bringToFront(topMaskLayer);
        }

        // ç¶å®šæ–‡å­— UI
        const valText = document.getElementById('val-text');
        const valColor = document.getElementById('val-color');
        const valOpacity = document.getElementById('val-opacity');

        function updateTextUI() {
            const obj = canvas.getActiveObject();
            if (obj && obj.type === 'i-text') {
                valText.value = obj.text;
                valColor.value = obj.fill;
                valOpacity.value = obj.opacity;
            }
        }
        
        canvas.on('selection:created', updateTextUI);
        canvas.on('selection:updated', updateTextUI);

        valText.oninput = () => { const o = canvas.getActiveObject(); if(o && o.type==='i-text'){ o.set({text: valText.value}); canvas.requestRenderAll(); }};
        valColor.oninput = () => { const o = canvas.getActiveObject(); if(o && o.type==='i-text'){ o.set({fill: valColor.value}); canvas.requestRenderAll(); }};
        valOpacity.oninput = () => { const o = canvas.getActiveObject(); if(o && o.type==='i-text'){ o.set({opacity: parseFloat(valOpacity.value)}); canvas.requestRenderAll(); }};


        // 5. é®ç½©ç¹ªåœ–é‚è¼¯ (æ ¸å¿ƒ Snapseed æ¨¡å¼)
        let isMaskMode = false;
        
        function switchMode(mode) {
            isMaskMode = (mode === 'mask');
            
            // åˆ‡æ› UI
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`tab-${mode}`).classList.add('active');
            
            document.getElementById('panel-text').classList.add('hidden');
            document.getElementById('panel-mask').classList.add('hidden');
            document.getElementById(`panel-${mode}`).classList.remove('hidden');

            if (isMaskMode) {
                if(!bgImage) { alert('è«‹å…ˆé–‹å•Ÿç…§ç‰‡'); switchMode('text'); return; }
                
                // é€²å…¥é®ç½©æ¨¡å¼
                canvas.discardActiveObject(); // å–æ¶ˆé¸å–æ–‡å­—
                canvas.requestRenderAll();
                
                // é–‹å•Ÿç•«ç­†
                canvas.isDrawingMode = true;
                const brush = new fabric.PencilBrush(canvas);
                brush.color = "rgba(255, 0, 0, 0.5)"; // ç´…è‰²åŠé€æ˜é è¦½
                brush.width = parseInt(document.getElementById('val-brush').value);
                canvas.freeDrawingBrush = brush;
                
                // é–å®šæ‰€æœ‰ç‰©ä»¶
                canvas.forEachObject(o => o.selectable = false);
            } else {
                // å›åˆ°æ–‡å­—æ¨¡å¼
                canvas.isDrawingMode = false;
                canvas.forEachObject(o => { if(o.type === 'i-text') o.selectable = true; });
            }
        }

        // èª¿æ•´ç­†åˆ·
        document.getElementById('val-brush').oninput = (e) => {
            document.getElementById('brush-size-text').innerText = e.target.value;
            if(canvas.freeDrawingBrush) canvas.freeDrawingBrush.width = parseInt(e.target.value);
        };

        // ç›£è½ï¼šç•«å®Œä¸€ç­†å¾Œ
        canvas.on('path:created', function(e) {
            if (!isMaskMode) return;
            
            const path = e.path;
            canvas.remove(path); // ç§»é™¤ç´…è‰²é è¦½ç·š
            
            // è¤‡è£½è·¯å¾‘ä¸¦åŠ å…¥é®ç½©ç¾¤çµ„
            path.clone(function(cloned) {
                cloned.set({
                    stroke: 'black', // é¡è‰²ä¸é‡è¦ï¼Œé‡é»æ˜¯ä¸é€æ˜
                    fill: null,
                    strokeWidth: path.strokeWidth,
                    strokeLineCap: 'round',
                    strokeLineJoin: 'round',
                    left: path.left,
                    top: path.top,
                    globalCompositeOperation: 'source-over'
                });
                
                maskPaths.push(cloned);
                applyMaskToTopLayer();
            });
        });

        function applyMaskToTopLayer() {
            if (!topMaskLayer) return;
            
            // å°‡æ‰€æœ‰è·¯å¾‘çµ„åˆæˆä¸€å€‹ Group
            const group = new fabric.Group(maskPaths, {
                absolutePositioned: true,
                inverted: false // æˆ‘å€‘è¦ã€Œé¡¯ç¤ºã€è¢«å¡—æŠ¹çš„å€åŸŸ
            });
            
            topMaskLayer.clipPath = group;
            topMaskLayer.dirty = true;
            canvas.requestRenderAll();
        }

        function undoLastMask() {
            if (maskPaths.length > 0) {
                maskPaths.pop();
                applyMaskToTopLayer();
            }
        }

        function resetMask() {
            maskPaths = [];
            applyMaskToTopLayer();
        }

        // 6. å­˜åœ–
        function saveImage() {
            if (!bgImage) return;
            
            // æš«æ™‚éš±è—æ§åˆ¶é …ï¼Œç¢ºä¿ç´”æ·¨
            canvas.discardActiveObject();
            canvas.renderAll();
            
            const link = document.createElement('a');
            // å€ç‡è¨­ç‚º 2 æé«˜æ¸…æ™°åº¦
            link.href = canvas.toDataURL({ format: 'png', quality: 0.9, multiplier: 2 });
            link.download = 'TextMask_Edited.png';
            link.click();
        }

    </script>
</body>
</html>
