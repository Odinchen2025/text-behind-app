<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ–‡å­—ç©¿è¶Šç‰¹æ•ˆ App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix"></script>
    <style>
        #canvas-container { touch-action: none; overflow: hidden; position: relative; }
        .controls { background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(5px); }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col">

    <header class="p-4 bg-blue-600 text-white text-center font-bold shadow-lg">
        äººåƒæ–‡å­—ç©¿è¶Šå·¥å…· (æ‰‹æ©Ÿå„ªåŒ–ç‰ˆ)
    </header>

    <main class="flex-1 flex flex-col items-center p-4">
        <div id="canvas-container" class="w-full aspect-square bg-white shadow-inner rounded-lg border-2 border-dashed border-gray-300 flex items-center justify-center relative">
            <canvas id="mainCanvas" class="max-w-full max-h-full"></canvas>
            <div id="loading" class="hidden absolute inset-0 bg-black/50 text-white flex items-center justify-center">AI è¾¨è­˜ä¸­...</div>
        </div>

        <div class="controls w-full mt-4 p-4 rounded-xl shadow-md space-y-4">
            <input type="file" id="upload" accept="image/*" class="w-full p-2 border rounded">
            
            <div class="flex gap-2">
                <input type="text" id="textInput" placeholder="è¼¸å…¥æ–‡å­—" class="flex-1 p-2 border rounded">
                <input type="color" id="colorPicker" value="#ffffff" class="w-12 h-10 border rounded">
            </div>

            <div class="text-sm text-gray-500 text-center">
                ğŸ’¡ æ“ä½œæç¤ºï¼šå–®æŒ‡ç§»å‹•æ–‡å­—ï¼Œé›™æŒ‡ç¸®æ”¾åœ–ç‰‡
            </div>
            
            <button id="download" class="w-full bg-green-500 text-white py-3 rounded-lg font-bold">å„²å­˜åœ–ç‰‡</button>
        </div>
    </main>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const upload = document.getElementById('upload');
        const textInput = document.getElementById('textInput');
        const colorPicker = document.getElementById('colorPicker');
        const loading = document.getElementById('loading');

        let img = new Image();
        let foregroundImg = null;
        let textX = 100, textY = 100;
        let scale = 1, lastScale = 1;
        let text = "Hello";

        // è¼‰å…¥ BodyPix æ¨¡å‹ç”¨æ–¼å»èƒŒ
        async function loadModel() {
            const net = await bodyPix.load();
            return net;
        }

        upload.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            loading.classList.remove('hidden');
            const reader = new FileReader();
            reader.onload = (event) => {
                img.onload = async () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    // AI é€²è¡Œäººåƒåˆ†å‰²
                    const net = await loadModel();
                    const segmentation = await net.segmentPerson(img);
                    
                    // å»ºç«‹å‰æ™¯åœ–å±¤ (äººåƒ)
                    const fgCanvas = document.createElement('canvas');
                    fgCanvas.width = img.width;
                    fgCanvas.height = img.height;
                    const fgCtx = fgCanvas.getContext('2d');
                    
                    fgCtx.drawImage(img, 0, 0);
                    const imageData = fgCtx.getImageData(0, 0, img.width, img.height);
                    for (let i = 0; i < segmentation.data.length; i++) {
                        if (segmentation.data[i] === 0) { // å¦‚æœæ˜¯èƒŒæ™¯ï¼Œè¨­ç‚ºé€æ˜
                            imageData.data[i * 4 + 3] = 0;
                        }
                    }
                    fgCtx.putImageData(imageData, 0, 0);
                    foregroundImg = fgCanvas;
                    
                    loading.classList.add('hidden');
                    draw();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        function draw() {
            if (!img.src) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 1. åº•å±¤ï¼šåŸå§‹ç…§ç‰‡
            ctx.drawImage(img, 0, 0);

            // 2. ä¸­å±¤ï¼šæ–‡å­—
            ctx.fillStyle = colorPicker.value;
            ctx.font = `bold ${canvas.width / 10}px Arial`;
            ctx.fillText(text, textX, textY);

            // 3. é ‚å±¤ï¼šå»èƒŒäººåƒ
            if (foregroundImg) {
                ctx.drawImage(foregroundImg, 0, 0);
            }
        }

        textInput.addEventListener('input', (e) => {
            text = e.target.value;
            draw();
        });

        colorPicker.addEventListener('input', draw);

        // ç°¡æ˜“æ‹–æ‹½èˆ‡ç¸®æ”¾é‚è¼¯ (æ‰‹æ©Ÿ Touch æ”¯æ´)
        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1) {
                const rect = canvas.getBoundingClientRect();
                textX = (e.touches[0].clientX - rect.left) * (canvas.width / rect.width);
                textY = (e.touches[0].clientY - rect.top) * (canvas.height / rect.height);
                draw();
            }
        });

        document.getElementById('download').onclick = () => {
            const link = document.createElement('a');
            link.download = 'edited-photo.png';
            link.href = canvas.toDataURL();
            link.click();
        };
    </script>
</body>
</html>
