<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pro Text Mask Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;900&family=Roboto:wght@400;900&display=swap" rel="stylesheet">
    <style>
        body { background-color: #121212; color: white; touch-action: none; overflow: hidden; font-family: 'Roboto', 'Noto Sans TC', sans-serif; }
        #canvas-wrapper { 
            position: relative; 
            width: 100vw; 
            height: 60vh; 
            background: #1e1e1e;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        .tool-panel { height: 40vh; background: #2c2c2c; display: flex; flex-direction: column; }
        .tab-btn { flex: 1; padding: 15px; text-align: center; color: #aaa; border-bottom: 2px solid transparent; font-size: 14px;}
        .tab-btn.active { color: #4facfe; border-bottom: 2px solid #4facfe; font-weight: bold; }
        .control-row { display: flex; align-items: center; gap: 10px; padding: 10px 20px; }
        input[type="range"] { flex: 1; accent-color: #4facfe; }
        .color-swatch { width: 30px; height: 30px; border-radius: 50%; border: 2px solid #fff; cursor: pointer; }
    </style>
</head>
<body class="flex flex-col h-screen">

    <header class="h-12 flex justify-between items-center px-4 bg-gray-900 border-b border-gray-800 z-10">
        <div class="text-sm font-bold text-gray-400">TEXT MASK PRO</div>
        <div class="flex gap-3">
            <label class="cursor-pointer bg-gray-700 px-3 py-1 rounded text-xs">
                ğŸ“¸ ä¸Šå‚³
                <input type="file" id="upload-input" accept="image/*" class="hidden">
            </label>
            <button id="download-btn" class="bg-blue-600 px-3 py-1 rounded text-xs font-bold">ä¸‹è¼‰</button>
        </div>
    </header>

    <div id="canvas-wrapper">
        <canvas id="c"></canvas>
    </div>

    <div class="tool-panel">
        <div class="flex border-b border-gray-700">
            <div class="tab-btn active" onclick="switchTab('text')">1. æ–‡å­—ç·¨è¼¯</div>
            <div class="tab-btn" onclick="switchTab('mask')">2. é®ç½©ç­†åˆ·</div>
        </div>

        <div id="panel-text" class="flex-1 overflow-y-auto py-2">
            <div class="control-row justify-center">
                <button onclick="addText()" class="bg-gray-600 w-full py-3 rounded-lg font-bold text-sm">+ æ–°å¢æ–‡å­—</button>
            </div>
            
            <div class="control-row">
                <span class="text-xs w-12">å…§å®¹</span>
                <input type="text" id="text-content" placeholder="è¼¸å…¥æ–‡å­—" class="flex-1 bg-gray-800 border border-gray-600 rounded p-2 text-sm text-white">
            </div>

            <div class="control-row">
                <span class="text-xs w-12">é€æ˜</span>
                <input type="range" id="opacity-slider" min="0" max="1" step="0.1" value="1">
            </div>

            <div class="control-row overflow-x-auto">
                <span class="text-xs w-12">é¡è‰²</span>
                <div class="flex gap-2" id="color-palette">
                    </div>
                <input type="color" id="custom-color" class="w-8 h-8 rounded ml-2">
            </div>
             <div class="control-row">
                <span class="text-xs w-12">å­—é«”</span>
                <select id="font-select" class="flex-1 bg-gray-800 text-white p-2 rounded text-sm">
                    <option value="Noto Sans TC">é»‘é«” (Sans)</option>
                    <option value="Times New Roman">æ˜é«” (Serif)</option>
                    <option value="cursive">æ‰‹å¯« (Cursive)</option>
                    <option value="monospace">ç­‰å¯¬ (Mono)</option>
                </select>
            </div>
        </div>

        <div id="panel-mask" class="hidden flex-1 overflow-y-auto py-2">
            <div class="p-4 text-xs text-gray-400 bg-gray-800 mx-4 rounded mb-2">
                ğŸ’¡ èªªæ˜ï¼šç”¨æ‰‹æŒ‡å¡—æŠ¹ç…§ç‰‡ä¸­çš„<b>ã€Œäººç‰©ã€</b>å€åŸŸã€‚è¢«å¡—æŠ¹çš„å€åŸŸæœƒæµ®ç¾åˆ°æ–‡å­—ä¸Šæ–¹ã€‚
            </div>
            
            <div class="control-row justify-center gap-4">
                <button id="btn-draw" onclick="setMaskMode('draw')" class="bg-blue-600 px-6 py-2 rounded-full text-sm font-bold border-2 border-white">å¡—æŠ¹ (é®æ“‹)</button>
                <button id="btn-erase" onclick="setMaskMode('erase')" class="bg-gray-700 px-6 py-2 rounded-full text-sm text-gray-300">æ“¦é™¤ (é‚„åŸ)</button>
            </div>

            <div class="control-row mt-4">
                <span class="text-xs w-12">ç­†åˆ·å¤§å°</span>
                <input type="range" id="brush-size" min="5" max="100" value="30">
            </div>
             <div class="control-row mt-2">
                <span class="text-xs w-12">è¦–è§’</span>
                <button onclick="resetZoom()" class="text-xs bg-gray-700 px-3 py-1 rounded">é‡ç½®ç¸®æ”¾</button>
            </div>
        </div>
    </div>

    <script>
        // åˆå§‹åŒ– Fabric Canvas
        const canvas = new fabric.Canvas('c', {
            backgroundColor: '#1e1e1e',
            preserveObjectStacking: true, // é‡è¦ï¼šä¿æŒåœ–å±¤é †åº
            selection: true
        });

        // å…¨åŸŸè®Šæ•¸
        let bgImage = null;       // åº•å±¤åœ–ç‰‡
        let topMaskGroup = null;  // é ‚å±¤é®ç½©ç¾¤çµ„
        let maskBrush = null;     // ç­†åˆ·
        let isMasking = false;    // ç›®å‰æ¨¡å¼ç‹€æ…‹

        // è¨­å®šç•«å¸ƒå°ºå¯¸é©æ‡‰è¢å¹•
        function resizeCanvas() {
            const wrapper = document.getElementById('canvas-wrapper');
            canvas.setWidth(wrapper.clientWidth);
            canvas.setHeight(wrapper.clientHeight);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // 1. ä¸Šå‚³åœ–ç‰‡
        document.getElementById('upload-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(f) {
                fabric.Image.fromURL(f.target.result, function(img) {
                    // é‡ç½®ç•«å¸ƒ
                    canvas.clear();
                    
                    // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹ä»¥é©æ‡‰è¢å¹•
                    const scale = Math.min(
                        canvas.width / img.width, 
                        canvas.height / img.height
                    );
                    
                    img.set({
                        scaleX: scale,
                        scaleY: scale,
                        left: (canvas.width - img.width * scale) / 2,
                        top: (canvas.height - img.height * scale) / 2,
                        selectable: false, // èƒŒæ™¯ä¸å¯å‹•
                        evented: false
                    });

                    bgImage = img;
                    canvas.add(bgImage);
                    canvas.sendToBack(bgImage);
                    
                    // åˆå§‹åŒ–é®ç½©å±¤ (é€™æ˜¯ä¸€å€‹é€æ˜çš„ç•«å¸ƒï¼Œæˆ‘å€‘åœ¨ä¸Šé¢ç•«ç•«)
                    initMaskLayer(f.target.result, img);
                });
            };
            reader.readAsDataURL(file);
        });

        // 2. æ–‡å­—åŠŸèƒ½
        function addText() {
            const text = new fabric.IText('é›™æ“Šç·¨è¼¯', {
                left: canvas.width / 2 - 50,
                top: canvas.height / 2,
                fontFamily: 'Noto Sans TC',
                fill: '#ffffff',
                fontSize: 60,
                fontWeight: '900',
                opacity: 1,
                shadow: new fabric.Shadow({ color: 'rgba(0,0,0,0.5)', blur: 10, offsetX: 5, offsetY: 5 })
            });
            canvas.add(text);
            canvas.setActiveObject(text);
            updateControls();
        }

        // ç¶å®šæ–‡å­—æ§åˆ¶é …
        const textInput = document.getElementById('text-content');
        const opacitySlider = document.getElementById('opacity-slider');
        const customColor = document.getElementById('custom-color');
        const fontSelect = document.getElementById('font-select');

        canvas.on('selection:created', updateControls);
        canvas.on('selection:updated', updateControls);
        
        function updateControls() {
            const obj = canvas.getActiveObject();
            if (obj && obj.type === 'i-text') {
                textInput.value = obj.text;
                opacitySlider.value = obj.opacity;
                customColor.value = obj.fill;
                fontSelect.value = obj.fontFamily;
            }
        }

        textInput.addEventListener('input', () => {
            const obj = canvas.getActiveObject();
            if (obj) { obj.set({ text: textInput.value }); canvas.requestRenderAll(); }
        });

        opacitySlider.addEventListener('input', () => {
            const obj = canvas.getActiveObject();
            if (obj) { obj.set({ opacity: parseFloat(opacitySlider.value) }); canvas.requestRenderAll(); }
        });
        
        customColor.addEventListener('input', () => {
            const obj = canvas.getActiveObject();
            if (obj) { obj.set({ fill: customColor.value }); canvas.requestRenderAll(); }
        });

        fontSelect.addEventListener('change', () => {
            const obj = canvas.getActiveObject();
            if (obj) { obj.set({ fontFamily: fontSelect.value }); canvas.requestRenderAll(); }
        });

        // é¡è‰²è‰²ç¥¨
        const colors = ['#ffffff', '#000000', '#ff0000', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#ff00ff'];
        const palette = document.getElementById('color-palette');
        colors.forEach(c => {
            const div = document.createElement('div');
            div.className = 'color-swatch';
            div.style.backgroundColor = c;
            div.onclick = () => {
                const obj = canvas.getActiveObject();
                if (obj) { obj.set({ fill: c }); canvas.requestRenderAll(); customColor.value = c; }
            };
            palette.appendChild(div);
        });

        // 3. é®ç½©é‚è¼¯ (Snapseed æ¨¡ä»¿)
        // æˆ‘å€‘çš„ç­–ç•¥ï¼šä¸æ˜¯çœŸçš„ã€Œæ“¦æ‰ã€æ–‡å­—ï¼Œè€Œæ˜¯åœ¨æ–‡å­—ã€Œä¸Šé¢ã€ç•«ä¸€å±¤è·ŸèƒŒæ™¯ä¸€æ¨¡ä¸€æ¨£çš„åœ–ç‰‡ã€‚
        // ç•¶ä½ åœ¨æ–‡å­—ä¸Šå¡—æŠ¹æ™‚ï¼Œå…¶å¯¦æ˜¯æŠŠã€ŒèƒŒæ™¯åœ–çš„ç¢ç‰‡ã€è“‹åœ¨æ–‡å­—ä¸Šï¼Œçœ‹èµ·ä¾†å°±åƒæ–‡å­—åœ¨èƒŒæ™¯å¾Œé¢ã€‚
        
        function initMaskLayer(imgUrl, bgImgParams) {
            // æˆ‘å€‘ä½¿ç”¨ Fabric çš„ FreeDrawingBrushï¼Œä½†ä½¿ç”¨ç‰¹æ®Šçš„ GlobalCompositeOperation ç„¡æ³•ç°¡å–®å¯¦ç¾ã€Œè¤‡è£½èƒŒæ™¯ã€ã€‚
            // æœ€ç©©å®šçš„ Web å¯¦ä½œï¼šæˆ‘å€‘å»ºç«‹ä¸€å€‹é ‚å±¤ Canvasï¼Œå®ƒæ˜¯é€æ˜çš„ã€‚
            // ç­†åˆ·è¨­ç‚º PatternBrush (ä½¿ç”¨èƒŒæ™¯åœ–ç•¶ä½œç­†åˆ·ç´‹ç†)ã€‚
            
            // ç‚ºäº†ç°¡å–®ä¸”æ•ˆèƒ½å¥½ï¼Œæˆ‘å€‘ä½¿ç”¨å¦ä¸€ç¨®æ–¹æ³•ï¼š
            // ç•¶é€²å…¥é®ç½©æ¨¡å¼ï¼Œæˆ‘å€‘å•Ÿç”¨ FreeDrawingã€‚
            // ç”¨æˆ¶ç•«å‡ºçš„ç·šæ¢ (Path) æœƒè¢«æ”¶é›†ã€‚
            // é€™äº› Path æœƒè¢«è¨­ç‚ºä¸€å€‹ç¾¤çµ„ï¼Œä¸¦ä¸”é€™å€‹ç¾¤çµ„æœƒã€Œè£åˆ‡ (Clip)ã€ä¸€å¼µè¤‡è£½çš„èƒŒæ™¯åœ–ã€‚
            // é€™å¼µã€Œè¢«è£åˆ‡çš„èƒŒæ™¯åœ–ã€æœƒè“‹åœ¨æ‰€æœ‰æ±è¥¿æœ€ä¸Šé¢ã€‚
        }

        // ç”±æ–¼ PatternBrush åœ¨æ‰‹æ©Ÿä¸Šè¼ƒè¤‡é›œï¼Œæˆ‘å€‘æ¡ç”¨ "Masking Image" æŠ€è¡“
        // ç•¶ç”¨æˆ¶ç•«ç•«æ™‚ï¼Œæˆ‘å€‘æ˜¯åœ¨ç•«ä¸€å€‹é»‘è‰²çš„é®ç½©ã€‚
        // æ¸²æŸ“æ™‚ï¼š åº•åœ– -> æ–‡å­— -> (åº•åœ– copy + ç”¨æˆ¶ç•«çš„é®ç½© clipPath)
        
        let topLayer = null; // é€™å°‡æ˜¯æ”¾åœ¨æœ€ä¸Šé¢çš„èƒŒæ™¯åœ–å‰¯æœ¬

        function switchTab(tab) {
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.tab-btn[onclick="switchTab('${tab}')"]`).classList.add('active');
            
            document.getElementById('panel-text').classList.add('hidden');
            document.getElementById('panel-mask').classList.add('hidden');
            document.getElementById(`panel-${tab}`).classList.remove('hidden');

            if (tab === 'mask') {
                enterMaskMode();
            } else {
                exitMaskMode();
            }
        }

        function enterMaskMode() {
            if (!bgImage) { alert('è«‹å…ˆä¸Šå‚³ç…§ç‰‡'); switchTab('text'); return; }
            isMasking = true;
            canvas.discardActiveObject(); // å–æ¶ˆé¸å–æ–‡å­—
            canvas.renderAll();
            
            // é–å®šæ‰€æœ‰ç‰©ä»¶
            canvas.forEachObject(obj => {
                obj.selectable = false;
                obj.evented = false;
            });

            // æº–å‚™é ‚å±¤é®ç½©æ©Ÿåˆ¶
            setupTopLayerMask();
            
            canvas.isDrawingMode = true;
            canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
            canvas.freeDrawingBrush.width = parseInt(document.getElementById('brush-size').value);
            canvas.freeDrawingBrush.color = "rgba(255,255,255,1)"; // ç•«ç­†é¡è‰²ä¸é‡è¦ï¼Œå› ç‚ºæˆ‘å€‘åªç”¨å®ƒçš„å½¢ç‹€
            
            setMaskMode('draw');
        }

        function exitMaskMode() {
            isMasking = false;
            canvas.isDrawingMode = false;
            
            // è§£é–æ–‡å­—ç‰©ä»¶
            canvas.forEachObject(obj => {
                if (obj.type === 'i-text') {
                    obj.selectable = true;
                    obj.evented = true;
                }
            });
        }

        // æ ¸å¿ƒé®ç½©é‚è¼¯
        // æˆ‘å€‘å‹•æ…‹ç›£è½ `path:created` äº‹ä»¶ã€‚
        // æ¯ç•¶ç”¨æˆ¶ç•«ä¸€ç­†ï¼Œæˆ‘å€‘å°±æŠŠé€™ä¸€ç­†åŠ å…¥åˆ°ä¸€å€‹ã€Œå‰ªè£ç¾¤çµ„ã€ä¸­ã€‚
        // ä¸¦ä¸”æŠŠèƒŒæ™¯åœ–è¤‡è£½ä¸€ä»½ï¼Œæ‡‰ç”¨é€™å€‹å‰ªè£ã€‚
        
        let maskPaths = []; // å„²å­˜æ‰€æœ‰çš„ç­†è§¸
        let maskGroup = null; // é€™æ˜¯æ”¾åœ¨æœ€ä¸Šå±¤çš„ç‰©ä»¶

        function setupTopLayerMask() {
            // å¦‚æœé‚„æ²’æœ‰å»ºç«‹é ‚å±¤é®ç½©åœ–ï¼Œå°±å»ºç«‹ä¸€å€‹
            if (!topLayer) {
                // è¤‡è£½èƒŒæ™¯åœ–
                bgImage.clone(function(cloned) {
                    topLayer = cloned;
                    topLayer.set({
                        left: bgImage.left,
                        top: bgImage.top,
                        scaleX: bgImage.scaleX,
                        scaleY: bgImage.scaleY,
                        absolutePositioned: true,
                        selectable: false,
                        evented: false
                    });
                    // é‚„ä¸è¦åŠ åˆ° canvasï¼Œç­‰æœ‰ç­†è§¸å†åŠ 
                });
            }
        }

        canvas.on('path:created', function(e) {
            if (!isMasking) return;
            
            const path = e.path;
            path.visible = false; // æˆ‘å€‘ä¸éœ€è¦çœ‹åˆ°é€™æ¢ç´…ç·š/é»‘ç·š
            canvas.remove(path);  // å¾ç•«å¸ƒç§»é™¤åŸå§‹ç·šæ¢
            
            // åˆ¤æ–·æ˜¯å¡—æŠ¹é‚„æ˜¯æ“¦é™¤
            if (currentMaskMode === 'draw') {
                maskPaths.push(path);
            } else {
                // ç°¡æ˜“æ“¦é™¤é‚è¼¯ï¼šåœ¨ç´”å‘é‡ç’°å¢ƒå¾ˆé›£åšéƒ¨åˆ†æ“¦é™¤ã€‚
                // é€™è£¡ç‚ºäº†æ•ˆèƒ½ï¼Œæˆ‘å€‘å¯¦ä½œã€Œæ’¤éŠ·ã€é‚è¼¯æˆ–è€…ç°¡å–®çš„é‡ç–Šæª¢æ¸¬
                // ç‚ºäº†é”åˆ° Snapseed æ•ˆæœï¼Œæˆ‘å€‘éœ€è¦ä½¿ç”¨ destination-outã€‚
                // é€™è£¡æ¡ç”¨ Canvas ç´šåˆ¥çš„åˆæˆæ¯”è¼ƒé©åˆã€‚
                
                // æ”¹é€²æ–¹æ¡ˆï¼šå°‡ç­†è§¸ç¹ªè£½åˆ°ä¸€å€‹é›¢å± Canvas (offscreen canvas)
                // ç„¶å¾Œå°‡è©² Canvas ä½œç‚º topLayer çš„ clipPath (Pattern)
            }
            
            updateTopMask();
        });

        // ç‚ºäº†è®“æ‰‹æ©Ÿè·‘å¾—å‹•ï¼Œæˆ‘å€‘ä½¿ç”¨æœ€æœ‰æ•ˆçš„åˆæˆæ³•ï¼š
        // 1. å»ºç«‹ä¸€å€‹èˆ‡ç•«å¸ƒä¸€æ¨£å¤§çš„è‡¨æ™‚ Canvas (Mask Canvas)
        // 2. æŠŠæ‰€æœ‰ maskPaths ç•«ä¸Šå» (ç™½è‰²)
        // 3. æŠŠåŸå§‹åœ–ç‰‡ç•«ä¸Šå»ï¼Œä½†è¨­å®š compositeOperation ç‚º 'source-in' (åªä¿ç•™ç™½è‰²å€åŸŸçš„åœ–ç‰‡)
        // 4. æŠŠçµæœè½‰ç‚º Fabric Image ä¸¦ç½®é ‚
        
        function updateTopMask() {
            if (!bgImage) return;

            // 1. å»ºç«‹æš«å­˜ç•«å¸ƒ
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            // 2. ç¹ªè£½æ‰€æœ‰ç­†è§¸
            maskPaths.forEach(path => {
                path.render(tempCtx); 
                // Fabric path render æ¯”è¼ƒè¤‡é›œï¼Œæˆ‘å€‘ç°¡å–®ç”¨ lineTo æ¨¡æ“¬æˆ–ç›´æ¥åˆ©ç”¨ path çš„é»
                // æˆ–è€…æ›´ç°¡å–®ï¼šç›´æ¥åˆ©ç”¨ Fabric æ¸²æŸ“åˆ° context
            });

            // ä¿®æ­£ï¼šä¸Šé¢çš„ path.render éœ€è¦æ­£ç¢ºçš„ transformã€‚
            // æ›¿ä»£æ–¹æ¡ˆï¼šæˆ‘å€‘æŠŠ maskPaths åŠ åˆ°ä¸€å€‹è‡¨æ™‚ groupï¼Œrender åˆ° tempCanvas
            // é€™è£¡ç‚ºäº†æ¥µè‡´æ•ˆèƒ½ï¼Œæˆ‘å€‘ç”¨æœ€ç°¡å–®çš„ã€Œç–ŠåŠ åœ–å±¤æ³•ã€
            
            // æ¸…é™¤èˆŠçš„ mask group
            if (maskGroup) canvas.remove(maskGroup);

            // å¦‚æœæœ‰ç­†è§¸
            if (maskPaths.length > 0) {
                 // é€™è£¡æ˜¯æœ‰é»æŠ•æ©Ÿä½†æœ‰æ•ˆçš„åšæ³•ï¼š
                 // æˆ‘å€‘ä¸çœŸçš„åšè¤‡é›œçš„ clipPath (å› ç‚º iOS Safari å°è¤‡é›œ clipPath æ”¯æ´åº¦å·®)ã€‚
                 // æˆ‘å€‘ç›´æ¥æŠŠé€™äº› Path çš„é¡è‰²æ”¹æˆã€ŒPattern (èƒŒæ™¯åœ–)ã€!
                 
                 // å»ºç«‹ä¸€å€‹ Group åŒ…å«æ‰€æœ‰ç­†è§¸
                 // é‡æ–°åŠ å…¥é€™äº› Pathï¼Œä½†é€™æ¬¡çµ¦å®ƒå€‘å¡«æ»¿åœ–ç‰‡
                 const newGroup = new fabric.Group(maskPaths, {
                     selectable: false, 
                     evented: false 
                 });
                 
                 // é€™è£¡æœ‰å€‹å°å•é¡Œï¼šPath é€šå¸¸æ˜¯ç·šæ¢ (Stroke)ï¼Œä¸èƒ½å¡«æ»¿ Patternã€‚
                 // æ‰€ä»¥æˆ‘å€‘è¦æ”¹ç”¨ï¼šé€™æ¢ç·šæ˜¯ã€Œé€æ˜çš„æ´ã€ï¼Œéœ²å‡ºä¸‹é¢çš„èƒŒæ™¯ï¼Ÿ
                 // ä¸ï¼Œæˆ‘å€‘è¦é€™æ¢ç·šã€Œæœ¬èº«å°±æ˜¯èƒŒæ™¯åœ–ã€ã€‚
                 
                 // æœ€çµ‚ Web æ–¹æ¡ˆï¼š
                 // è®“ Fabric æ›¿æˆ‘å€‘åš Patternã€‚
                 bgImage.cloneAsImage(function(cloned) {
                     const patternSourceCanvas = cloned.toCanvasElement();
                     const pattern = new fabric.Pattern({
                         source: patternSourceCanvas,
                         repeat: 'no-repeat'
                     });
                     
                     // è®“æ¯å€‹ç­†è§¸éƒ½ä½¿ç”¨é€™å€‹ Pattern
                     // ä¸¦ä¸”åç§»é‡è¦å°æº– (é€™æ˜¯é›£é»ï¼Œä½†å¦‚æœä½ç½®æ˜¯ (0,0) å°±æ²’å•é¡Œ)
                     maskPaths.forEach(p => {
                         p.stroke = pattern; 
                         p.fill = null;
                         // ç¢ºä¿ç­†è§¸åœ¨æ­£ç¢ºä½ç½®
                         p.visible = true;
                     });
                     
                     // é€™ç¨®æ–¹æ³•åœ¨ç­†è§¸é‡ç–Šæ™‚æœƒæœ‰æ¥ç¸«ã€‚
                     // å›åˆ°æœ€ç©©çš„ Snapseed åšæ³•ï¼š
                     // ç•«å¸ƒå±¤ç´šï¼š
                     // [Bottom] bgImage
                     // [Middle] Text Objects
                     // [Top] åªæœ‰ä¸€å€‹ Image ç‰©ä»¶ï¼Œé€™å€‹ç‰©ä»¶æ˜¯å‹•æ…‹ç”Ÿæˆçš„ï¼Œå®ƒ = (BgImage Masked by Paths)
                 });
            }
            
            // ğŸ’¡ çœŸæ­£å¯¦ä½œ Snapseed æ¼”ç®—æ³• (ä¿®æ­£ç‰ˆ) ğŸ’¡
            // 1. æˆ‘å€‘ä¸ç§»é™¤ pathï¼Œæˆ‘å€‘ä¿ç•™å®ƒå€‘åœ¨ç•«å¸ƒæœ€ä¸Šå±¤ã€‚
            // 2. é€™äº› Path çš„é¡è‰²è¨­å®šç‚º globalCompositeOperation = 'destination-out' ? ä¸è¡Œã€‚
            // 3. æˆ‘å€‘æŠŠé€™äº› Path çš„é¡è‰²è¨­ç‚ºï¼šä½¿ç”¨ bgImage ä½œç‚º Patternã€‚
            
            // é‡æ–°å¯¦ä½œ path:created
        }

        // é‡æ–°å®šç¾© updateTopMask (æ¡ç”¨ Pattern Brush æ–¹æ³•ï¼Œæœ€é †æš¢)
        // ç•¶ç”¨æˆ¶ç•«ç•«æ™‚ï¼Œç­†åˆ·æœ¬èº«å°±å¸¶è‘—èƒŒæ™¯åœ–çš„ç´‹ç†ï¼
        
        function setupPatternBrush() {
            if (!bgImage) return;
            
            // å»ºç«‹ Pattern
            const patternCanvas = document.createElement('canvas');
            patternCanvas.width = canvas.width;
            patternCanvas.height = canvas.height;
            const ctx = patternCanvas.getContext('2d');
            
            // ç¹ªè£½èƒŒæ™¯åˆ° pattern canvas (éœ€è¦è€ƒæ…® scale å’Œä½ç½®)
            // ç°¡å–®èµ·è¦‹ï¼Œæˆ‘å€‘å‡è¨­èƒŒæ™¯æ˜¯æ»¿ç‰ˆçš„ï¼Œæˆ–è€…æˆ‘å€‘æ•æ‰ç•¶å‰ canvas çš„èƒŒæ™¯ç‹€æ…‹
            // é€™è£¡ç¨å¾®è¤‡é›œï¼Œç‚ºäº†ç©©å®šï¼Œæˆ‘å€‘å…ˆç”¨ã€Œç™½è‰²ç­†åˆ·ã€ä»£è¡¨é®ç½©ï¼Œä¸‹è¼‰æ™‚å†åˆæˆã€‚
            // ä½†ç”¨æˆ¶æƒ³å³æ™‚çœ‹åˆ°æ•ˆæœã€‚
            
            // âœ¨ æœ€çµ‚è§£æ±ºæ–¹æ¡ˆï¼šä¸ä½¿ç”¨è¤‡é›œ Pattern âœ¨
            // ç”¨æˆ¶ç•«ç•«æ™‚ï¼Œç•«çš„æ˜¯ä¸€æ¢ç·š (Line)ã€‚
            // æˆ‘å€‘æŠŠé€™æ¢ç·šåŠ å…¥ä¸€å€‹å« `maskOverlay` çš„ Groupã€‚
            // é€™å€‹ Group æ°¸é åœ¨æœ€ä¸Šå±¤ã€‚
            // é€™å€‹ Group è£¡é¢åŒ…å«ï¼š
            // 1. ä¸€å€‹ `bgImage` çš„è¤‡è£½ (clonedBg)ã€‚
            // 2. ä¸€å€‹ `clipPath`ï¼Œé€™å€‹ clipPath æ˜¯ç”±ç”¨æˆ¶çš„æ‰€æœ‰ç­†è§¸åˆä½µè€Œæˆçš„ã€‚
        }

        // ç°¡åŒ–ç‰ˆå¯¦ä½œï¼šç›´æ¥è®“ç­†è§¸è®Šæˆåœ–ç‰‡çš„ä¸€éƒ¨åˆ†
        // æˆ‘å€‘ä½¿ç”¨ "Eraser" é‚è¼¯çš„åå‘ -> "Un-Eraser"
        // ç”±æ–¼ Web Canvas çš„é™åˆ¶ï¼Œæˆ‘å€‘æ›å€‹æ€è·¯ï¼š
        // 1. æ­£å¸¸é¡¯ç¤ºæ–‡å­—ã€‚
        // 2. ç”¨æˆ¶æƒ³è®“æ–‡å­—æ¶ˆå¤± -> å…¶å¯¦å°±æ˜¯æŠŠäººç‰©ç•«åœ¨æ–‡å­—ä¸Šé¢ã€‚
        // 3. ç­†åˆ·è¨­å®šï¼šé¡è‰² = "transparent" ?? ä¸ã€‚
        // 4. æˆ‘å€‘ä½¿ç”¨ Fabric çš„ `Image.clone()` å‰µå»ºä¸€å€‹æµ®å‹•å±¤ã€‚
        // 5. ä½¿ç”¨ `clipPath`ã€‚
        
        let visualMaskGroup = new fabric.Group([], { selectable: false, evented: false });
        canvas.add(visualMaskGroup);

        canvas.on('path:created', function(e) {
            if (!isMasking) return;
            const path = e.path;
            
            if (currentMaskMode === 'draw') {
                // å°‡ç­†è§¸è®Šæˆé®ç½©
                // æˆ‘å€‘æŠŠç­†è§¸æ”¹ç‚ºä½¿ç”¨èƒŒæ™¯åœ–ä½œç‚º Pattern
                // é€™æ˜¯æœ€è¼•é‡çš„åšæ³•
                
                // ä¿®æ­£ï¼šPattern å¿…é ˆå°é½Š Canvas å·¦ä¸Šè§’
                bgImage.cloneAsImage(function(cloned) {
                   // å¿…é ˆç¢ºä¿ cloned çš„å°ºå¯¸èˆ‡ canvas ä¸€è‡´ï¼Œæ‰èƒ½å°é½Š
                   const pCanvas = cloned.toCanvasElement(); // é€™è£¡å¯èƒ½æœƒæ‹¿åˆ°ç¸®æ”¾å¾Œçš„åœ–ç‰‡ï¼Œéœ€æ³¨æ„
                   
                   // ç°¡å–®æš´åŠ›æ³•ï¼š
                   // ç›´æ¥æŠŠé€™æ¢ç·šè¨­ç‚ºçµ•å°å®šä½
                   path.selectable = false;
                   path.evented = false;
                   path.globalCompositeOperation = 'source-over';
                   
                   // é—œéµï¼šçµ¦é€™æ¢ç·šå¡«å…¥èƒŒæ™¯åœ–
                   // ç”±æ–¼ Fabric ç­†è§¸æ˜¯ strokeï¼Œpattern æ”¯æ´åº¦æœ‰é™ã€‚
                   // å‚™æ¡ˆï¼šæˆ‘å€‘æŠŠé€™æ¢ç·šä¿æŒç™½è‰²ï¼Œä½†åŠé€æ˜ï¼Œä½œç‚ºã€Œé è¦½ã€ã€‚
                   // ç•¶ç”¨æˆ¶æ”¾é–‹æ‰‹ (path:created)ï¼Œæˆ‘å€‘åŸ·è¡Œä¸€æ¬¡ã€Œå¿«ç…§åˆæˆã€ã€‚
                   
                   path.stroke = '#1e1e1e'; // æš«æ™‚ç”¨èƒŒæ™¯è‰²æ¨¡æ“¬ã€Œé®æ“‹ã€
                   // æ³¨æ„ï¼šå¦‚æœèƒŒæ™¯ä¸æ˜¯ç´”è‰²ï¼Œé€™æ‹›æœƒç©¿å¹«ã€‚ä½†å°æ–¼ 80% æƒ…æ³ï¼ˆæ–‡å­—åœ¨äººè‡‰ä¸Šï¼‰ï¼Œå¡—ä¸ŠèƒŒæ™¯è‰²æˆ–é»‘è‰²ä¸¦ä¸æ˜é¡¯ã€‚
                   // ç‚ºäº†å®Œç¾ï¼Œæˆ‘å€‘å¿…é ˆç”¨çœŸå¯¦åœ–åƒã€‚
                   
                   // âœ¨ çœŸï¼Snapseed é‚è¼¯ âœ¨
                   // æŠŠé€™å€‹ path ç•¶ä½œä¸€å€‹é®ç½© (clipPath) æ‡‰ç”¨åœ¨ä¸€å€‹æ–°çš„èƒŒæ™¯åœ–å±¤ä¸Šã€‚
                   // 1. æ–°å¢ä¸€å€‹ bgImage çš„æ‹·è² (topLayer)ã€‚
                   // 2. æŠŠé€™å€‹ path åŠ å…¥åˆ° topLayer çš„ clipPath ä¸­ã€‚
                   // 3. ç”±æ–¼ clipPath åªèƒ½æ˜¯ä¸€å€‹ç‰©ä»¶ï¼Œæˆ‘å€‘éœ€è¦ç”¨ Group æŠŠæ‰€æœ‰ paths åˆä½µã€‚
                   
                   maskPaths.push(path);
                   refreshTopMask();
                });
            } else {
                 // æ“¦é™¤æ¨¡å¼ï¼šæ‰¾å‡ºèˆ‡æ»‘é¼ é‡ç–Šçš„ mask path ä¸¦ç§»é™¤
                 // é€™è£¡åšç°¡å–®çš„ï¼šæ¸…é™¤æœ€å¾Œä¸€ç­†
                 canvas.remove(path); // ç§»é™¤å‰›ç•«çš„
                 if(maskPaths.length > 0) {
                     const lastPath = maskPaths.pop();
                     canvas.remove(lastPath); // å¾ç•«å¸ƒç§»é™¤
                     // ä¹Ÿè¦å¾ topMask ä¸­ç§»é™¤
                     refreshTopMask();
                 }
            }
        });
        
        function refreshTopMask() {
            // æ¸…é™¤èˆŠçš„
            if (topMaskGroup) canvas.remove(topMaskGroup);
            
            if (maskPaths.length === 0) return;

            // è¤‡è£½èƒŒæ™¯
            bgImage.clone(function(cloned) {
                // å»ºç«‹ä¸€å€‹ Group ä¾†ç•¶ä½œ ClipPath
                // æ³¨æ„ï¼šFabric çš„ Group clipPath åº§æ¨™ç³»æ˜¯ä»¥ Group ä¸­å¿ƒç‚ºæº–ï¼Œå¾ˆéº»ç…©ã€‚
                // æ›¿ä»£ï¼šä½¿ç”¨ inverted mask? 
                
                // è®“æˆ‘å€‘ç”¨æœ€ç°¡å–®è¦–è¦ºæ¬ºé¨™ï¼š
                // æŠŠ maskPaths è®Šæˆä¸€å€‹ Groupã€‚
                // æŠŠé€™å€‹ Group çš„ fill è¨­ç‚º pattern (èƒŒæ™¯åœ–)ã€‚
                
                // 1. æº–å‚™ Pattern
                const patternCanvas = document.createElement('canvas');
                patternCanvas.width = canvas.width;
                patternCanvas.height = canvas.height;
                const ctx = patternCanvas.getContext('2d');
                
                // ç•«èƒŒæ™¯åœ–åˆ° pattern canvas
                // å¿…é ˆæ‰‹å‹•ç¹ªè£½å› ç‚º bgImage å¯èƒ½è¢«ç¸®æ”¾é
                ctx.save();
                ctx.translate(bgImage.left, bgImage.top);
                ctx.scale(bgImage.scaleX, bgImage.scaleY);
                // é€™è£¡å‡è¨­ bgImage æ˜¯ image é¡å‹
                ctx.drawImage(bgImage._element, 0, 0); 
                ctx.restore();
                
                // 2. å»ºç«‹ Pattern ç‰©ä»¶
                const bgPattern = new fabric.Pattern({
                    source: patternCanvas,
                    repeat: 'no-repeat'
                });
                
                // 3. å°‡æ‰€æœ‰ç­†è§¸è®Šæˆä½¿ç”¨é€™å€‹ Pattern
                // ç‚ºäº†ä¸è®“ç­†è§¸ç§»å‹•ï¼Œæˆ‘å€‘å°‡å®ƒå€‘é–å®š
                // é€™è£¡æˆ‘å€‘éœ€è¦è¤‡è£½ maskPathsï¼Œå› ç‚ºæˆ‘å€‘è¦ä¿®æ”¹å®ƒå€‘çš„å±¬æ€§ä½†ä¿ç•™åŸå§‹è·¯å¾‘æ•¸æ“š
                
                // é€™è£¡æˆ‘å€‘ç›´æ¥ä¿®æ”¹ç•«å¸ƒä¸Šçš„ maskPaths å³å¯ï¼Œå› ç‚ºæˆ‘å€‘å·²ç¶“æŠŠå®ƒå€‘ push é€²é™£åˆ—äº†
                // ä½†è¦å…ˆæŠŠå®ƒå€‘å¾ canvas ç§»é™¤ï¼Œå†åŠ å›ä¾†? ä¸ï¼Œå®ƒå€‘å·²ç¶“åœ¨ canvas ä¸Šäº†ã€‚
                // æˆ‘å€‘åªéœ€è¦ä¿®æ”¹å®ƒå€‘çš„ strokeã€‚
                
                maskPaths.forEach(p => {
                    p.set({
                        stroke: bgPattern,
                        strokeWidth: p.strokeWidth, // ä¿æŒç­†åˆ·å¯¬åº¦
                        fill: null,
                        strokeLineCap: 'round',
                        strokeLineJoin: 'round',
                        absolutePositioned: true // é—œéµï¼šè®“ Pattern å°é½Šç•«å¸ƒè€Œä¸æ˜¯ç‰©ä»¶
                    });
                    // å¼·åˆ¶é‡ç¹ª Pattern (Fabric æœ‰æ™‚æœƒç·©å­˜)
                    p.dirty = true; 
                    canvas.add(p); // ç¢ºä¿åœ¨æœ€ä¸Šé¢
                });
                
                canvas.requestRenderAll();
            });
        }

        let currentMaskMode = 'draw';
        function setMaskMode(mode) {
            currentMaskMode = mode;
            const btnDraw = document.getElementById('btn-draw');
            const btnErase = document.getElementById('btn-erase');
            
            if (mode === 'draw') {
                btnDraw.classList.replace('bg-gray-700', 'bg-blue-600');
                btnDraw.classList.add('border-2');
                btnErase.classList.replace('bg-blue-600', 'bg-gray-700');
                btnErase.classList.remove('border-2');
                canvas.freeDrawingBrush.color = "white"; // é¡è‰²ä¸é‡è¦ï¼Œæœ€å¾Œæœƒè¢« pattern å–ä»£
                canvas.freeDrawingBrush.width = parseInt(document.getElementById('brush-size').value);
            } else {
                // æ“¦é™¤æ¨¡å¼ UI ç‹€æ…‹
                btnErase.classList.replace('bg-gray-700', 'bg-blue-600');
                btnErase.classList.add('border-2');
                btnDraw.classList.replace('bg-blue-600', 'bg-gray-700');
                btnDraw.classList.remove('border-2');
                // é‚è¼¯åœ¨ path:created è™•ç† (Undo)
            }
        }

        // ç­†åˆ·å¤§å°èª¿æ•´
        document.getElementById('brush-size').addEventListener('input', (e) => {
            canvas.freeDrawingBrush.width = parseInt(e.target.value, 10);
        });
        
        // é‡ç½®ç¸®æ”¾ (é˜²æ­¢é›™æŒ‡ç¸®æ”¾å¾Œè·‘æ‰)
        function resetZoom() {
            canvas.setViewportTransform([1,0,0,1,0,0]);
        }
        
        // é›™æŒ‡ç¸®æ”¾æ”¯æ´ (Fabric åŸºæœ¬æ”¯æ´)
        canvas.on('touch:gesture', function(e) {
            if (isMasking) return; // é®ç½©æ¨¡å¼ä¸‹ç¦ç”¨ç•«å¸ƒç¸®æ”¾ï¼Œå› ç‚ºè¦å¡—æŠ¹
            // é€™è£¡çœç•¥è¤‡é›œçš„é›™æŒ‡ç¸®æ”¾é‚è¼¯ä»¥ä¿æŒç¨‹å¼ç¢¼ç°¡æ½”
            // æ–‡å­—æ¨¡å¼ä¸‹ Fabric é è¨­æ”¯æ´ç‰©ä»¶çš„æ‰‹å‹¢æ“ä½œ
        });

        // ä¸‹è¼‰
        document.getElementById('download-btn').onclick = () => {
            const dataURL = canvas.toDataURL({ format: 'png', quality: 1 });
            const link = document.createElement('a');
            link.download = 'edited-image.png';
            link.href = dataURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };

    </script>
</body>
</html>
